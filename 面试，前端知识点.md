# vue2 父子生命周期的执行顺序

父：beforcreate created beforemount  
子：beforcreate created beforemount mounted
父：mounted

# vue2 在 created 里面如何获取dom

在 beforcreate created beforemount 中 只要是异步获取，都可以获取dom
比如：

1. settimeout，promise.xxx，async await
   async created(){
   let res = await axios({
   url:'xxx'
   })
   }
2. vue自带的 this.nexttick(()=>{})

# 为什么不在 beforcreate 里面发送请求？beforcreate 和 created 有什么区别？

1. 因为如果这个请求是封装在 methods 里面的方法 在 beforcreate 里面就 获取不到 方法 会报错
2. beforcreate生命周期 既没有获取到实例，也没有挂载到dom，
   created 生命周期 已经获取到实例，但是还没进行挂载，
   并且 这个生命周期里面可以获取 methods 里的方法

# 发送接口请求 是放在 created 还是 mounted？

1. 这个可以选择，因为有一个 父子组件生命周期 执行顺序的问题，
   所以 看 请求是放在子组件还 是父组件中的，请求放的位置不一样，
   展示顺序也不一样，如果优先加载子组件的数据，那么父组件的请求
   要放在 mounted 中，如果优先加载父组件的数据，那么父组件的请求
   放在 created 中

# keep-alive 的作用？执行了那些生命周期？

1. 它的作用就是缓存路由
2. 除了组件 自带的 8 个生命周期 还增加了 actived 和 deactived 两个生命周期

# 第二次或者第N次进去组件会执行那些生命周期？

如果当前组价加入了keep-alive 第二次和第N次进入那么只会执行一个生命周期 activated，第一次进入会执行 五个 beforcreate created beforemount mounted activated

如果没有加入，执行 beforcreate created beforemount mounted

# 用过那些生命周期？分别使用场景？

1. 常用的 created，mounted，befordestory
2. 如果想同步获取dom 那么就在mounted 如果是有请求，那么就取决于有没有父子关系，如果想要子组件内容先渲染，那么请求就放在父组件的mounted 里面

# 组件通信的方式

1. 父-子  
    在父组件里的子组件标签上 写 v-bind：name="value"
   子组件用props 接收（这种方式不能直接修改父组件的数据）
   props:{
   value:{
   type:object,
   default:{}
   }
   }

   $refs传
   子组件直接使用 $parent（这种方式可以直接修改父组件的数据）
   子组件还可以用 v-bind="$attrs"接受

   子传父
   this.$emit('name',value)
   父接收
   @name='funcname'

2. 爷-孙
   provide('name',value)
   inject('name')

provide('name',{value1,funcname})

<!-- 这里子组件拿到 funcname 可以传值给父 -->

let {value1,funcname} = inject('name')

3. 同级
   vuex 或 pinia

# 如何找到父组件的根组件

this.$root

# vuex mutations 和 actions 的区别？

mutations 返回同步，意思同步操作 我们放在这里
actions 返回 promise对象，执行异步操作，异步存储我们放到这里执行

# history 和 hash 模式的区别和实现原理？

区别：
history 使用 pushState方法，使得地址栏变化的同时修改浏览器历史记录，使得页面不会重新加载。在url地址栏不会有#。

hash 利用URL的hash (#)部分来改变URL，然后监听hashchange事件来触发路由更新。实际页面并不会重新渲染，但URL会添加一个对应的锚点。

# 关于API

1. $set
数据更新了，视图没有更新的情况？
这种一般是对象类型的数据发生变化，才会存在不同步，
解决这种情况的办法 使用this.$set(obj,obj.value,new value)

2. $nexttick
   nexttick 就是vue提供的异步方法，可以将我们更新的数据，延时到下一个事件循环中执行，减少真实dom操作，使我们获取到最新的dom,
   它返回的是一个promise对象，异步执行回调函数

<script>
  this.$nexttick(()=>{
  console.log('1')
  })

  $nexttick(callback){
  return Promise.resolve().then(()=>{
  callback()
  })
  }
</script>

# watch 的使用

<script>
  
  watch:{
    // str:function(new,old){

    // }

    // 监听基本类型 直接监听就行
    // str(new,old){

    // }

    // 监听对象，修改对象里面的属性，需要用到深度监听
    obj:{
      handler(new,old){

      },
      immediate:true,
      deep:true
    }
  }
</script>

# 自定义指令

1. 全局指令 在main.ts 里面使用
   Vue.direction('deom',{
   inserted:function(a){
   console.log(a)
   }
   })

使用 v-demo='1'

2.  局部指令 在具体vue 文件中 使用

directives:{
demo:{
bind:function(el){
console.log(1)
}
}
}

# 数组 slice 和 splice 的区别

slice 截取 返回一个新的数组
slice(1) slice(1,3) slice(-1)

splice 删除，替换，插入
返回 删除的 元素 是一个数组
会改变原数组
删除 splice(index,1)
替换 splice(index,1,test)

# 统计一个字符串 出现的次数 和 最多的那个值

<script>
  let str = 'aabbccccdddddaabbccddaaaa'
  let obj = {}
  for(let i = 0;i<str.length;i++){
    if(obj[str[i]]){
      obj[str[i]]++
    }else {
      obj[str[i]] = 1
    }
  }
</script>

# vue methods 和 computed 有什么区别？

执行结果没有任何区别。但是 methods 只要调用这个方法，他就会去执行，computed 只有依赖更新以后，才回去重新计算，节省更多的性能

# vue2 和 vue3 的区别？
